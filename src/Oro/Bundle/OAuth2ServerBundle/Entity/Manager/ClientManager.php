<?php

namespace Oro\Bundle\OAuth2ServerBundle\Entity\Manager;

use Doctrine\Common\Persistence\ManagerRegistry;
use Doctrine\ORM\EntityManagerInterface;
use Oro\Bundle\EntityBundle\ORM\EntityIdAccessor;
use Oro\Bundle\OAuth2ServerBundle\Entity\Client;
use Oro\Bundle\OrganizationBundle\Entity\Organization;
use Oro\Bundle\SecurityBundle\Acl\Domain\DomainObjectReference;
use Oro\Bundle\SecurityBundle\Authentication\TokenAccessorInterface;
use Oro\Bundle\SecurityBundle\Owner\EntityOwnerAccessor;
use Symfony\Component\Security\Acl\Util\ClassUtils;
use Symfony\Component\Security\Core\Authorization\AuthorizationCheckerInterface;
use Symfony\Component\Security\Core\Encoder\EncoderFactoryInterface;
use Symfony\Component\Security\Core\Encoder\PasswordEncoderInterface;

/**
 * Provides a set of methods to simplify manage of the OAuth 2.0 Client entity.
 */
class ClientManager
{
    /** @var ManagerRegistry */
    private $doctrine;

    /** @var EncoderFactoryInterface */
    private $encoderFactory;

    /** @var TokenAccessorInterface */
    private $tokenAccessor;

    /** @var AuthorizationCheckerInterface */
    private $authorizationChecker;

    /** @var EntityOwnerAccessor */
    private $entityOwnerAccessor;

    /** @var EntityIdAccessor */
    private $entityIdAccessor;

    /**
     * @param ManagerRegistry               $doctrine
     * @param EncoderFactoryInterface       $encoderFactory
     * @param TokenAccessorInterface        $tokenAccessor
     * @param AuthorizationCheckerInterface $authorizationChecker
     * @param EntityOwnerAccessor           $entityOwnerAccessor
     * @param EntityIdAccessor              $entityIdAccessor
     */
    public function __construct(
        ManagerRegistry $doctrine,
        EncoderFactoryInterface $encoderFactory,
        TokenAccessorInterface $tokenAccessor,
        AuthorizationCheckerInterface $authorizationChecker,
        EntityOwnerAccessor $entityOwnerAccessor,
        EntityIdAccessor $entityIdAccessor
    ) {
        $this->doctrine = $doctrine;
        $this->encoderFactory = $encoderFactory;
        $this->tokenAccessor = $tokenAccessor;
        $this->authorizationChecker = $authorizationChecker;
        $this->entityOwnerAccessor = $entityOwnerAccessor;
        $this->entityIdAccessor = $entityIdAccessor;
    }

    /**
     * Checks whether access to creation of Client entity is granted.
     *
     * @param string $ownerEntityClass
     * @param int    $ownerEntityId
     *
     * @return bool
     */
    public function isCreationGranted(string $ownerEntityClass, int $ownerEntityId): bool
    {
        return $this->hasModificationPermissions(
            $ownerEntityClass,
            $ownerEntityId
        );
    }

    /**
     * Checks whether access to modification and deletion of the given Client entity is granted.
     *
     * @param Client $entity
     *
     * @return bool
     */
    public function isModificationGranted(Client $entity): bool
    {
        return $this->hasModificationPermissions(
            $entity->getOwnerEntityClass(),
            $entity->getOwnerEntityId(),
            $entity
        );
    }

    /**
     * Sets missing, auto-generated and default values to the given Client entity
     * and store it to the database if the flushing is requested.
     *
     * @param Client $client The entity to update
     * @param bool   $flush  Whether to store the entity to the database (default true)
     */
    public function updateClient(Client $client, bool $flush = true): void
    {
        $this->setAutoGeneratedFields($client);
        if (!$client->getOrganization()) {
            $client->setOrganization($this->tokenAccessor->getOrganization());
        }
        if (!$client->getScopes() && null !== $client->getScopes()) {
            $client->setScopes(null);
        }
        if (!$client->getRedirectUris() && null !== $client->getRedirectUris()) {
            $client->setRedirectUris(null);
        }

        // BAP-18427: remove this block when other grant types is implemented
        if (!$client->getGrants()) {
            $client->setGrants(['client_credentials']);
        }

        if ($flush) {
            $em = $this->getEntityManager();
            $em->persist($client);
            $em->flush();
        }
    }

    /**
     * Activates the given Client entity.
     *
     * @param Client $client The entity to be activated
     */
    public function activateClient(Client $client): void
    {
        $client->setActive(true);
        $this->getEntityManager()->flush();
    }

    /**
     * Deactivates the given Client entity.
     *
     * @param Client $client The entity to be activated
     */
    public function deactivateClient(Client $client): void
    {
        $client->setActive(false);
        $this->getEntityManager()->flush();
    }

    /**
     * Deletes the given Client entity from the database.
     *
     * @param Client $client The entity to be activated
     */
    public function deleteClient(Client $client): void
    {
        $em = $this->getEntityManager();
        $em->remove($client);
        $em->flush();
    }

    /**
     * @param Client $client
     */
    private function setAutoGeneratedFields(Client $client): void
    {
        if (null === $client->getId()) {
            if (!$client->getIdentifier()) {
                $client->setIdentifier($this->generateToken(32));
            }
            if (!$client->getPlainSecret()) {
                $client->setPlainSecret($this->generateToken(128));
            }
        }
        if ($client->getPlainSecret()) {
            $salt = $this->generateToken(50);
            $client->setSecret(
                $this->getSecretEncoder($client)->encodePassword($client->getPlainSecret(), $salt),
                $salt
            );
        }
    }

    /**
     * @param Client $client
     *
     * @return PasswordEncoderInterface
     */
    private function getSecretEncoder(Client $client): PasswordEncoderInterface
    {
        return $this->encoderFactory->getEncoder($client);
    }

    /**
     * @param int $maxLength
     *
     * @return string
     */
    private function generateToken(int $maxLength): string
    {
        $randomString = '';
        $minLength = (int)($maxLength * 0.6);
        while (strlen($randomString) < $minLength) {
            $randomString .= rtrim(
                strtr(base64_encode(hash('sha256', random_bytes($maxLength), true)), '+/', '-_'),
                '='
            );
        }

        return str_shuffle(substr($randomString, 0, $maxLength));
    }

    /**
     * @param string      $ownerEntityClass
     * @param int         $ownerEntityId
     * @param Client|null $entity
     *
     * @return bool
     */
    private function hasModificationPermissions(
        string $ownerEntityClass,
        int $ownerEntityId,
        Client $entity = null
    ): bool {
        $currentUser = $this->tokenAccessor->getUser();
        if ($currentUser instanceof $ownerEntityClass
            && $this->entityIdAccessor->getIdentifier($currentUser) === $ownerEntityId
        ) {
            return true;
        }

        $owner = $this->getEntityManager()->find($ownerEntityClass, $ownerEntityId);
        if (null === $owner) {
            return false;
        }

        if (null === $entity) {
            return $this->hasPermissionsToManageClient($owner);
        }

        $organization = $entity->getOrganization();
        if (null === $organization) {
            return $this->hasPermissionsToManageClient($owner);
        }

        $result = true;
        $ownerOwner = $this->entityOwnerAccessor->getOwner($owner);
        $ownerOrganization = $this->entityOwnerAccessor->getOrganization($owner);
        if (null !== $ownerOrganization) {
            if ($ownerOrganization->getId() === $organization->getId()) {
                $result = $this->hasPermissionsToManageClient($owner);
            } else {
                $result = $this->hasPermissionsToManageClient(
                    $this->getDomainObjectReference($owner, $ownerOwner, $ownerOrganization)
                );
            }
        } elseif ($ownerOwner instanceof Organization) {
            if ($ownerOwner->getId() === $organization->getId()) {
                $result = $this->hasPermissionsToManageClient($owner);
            } else {
                $result = $this->hasPermissionsToManageClient(
                    $this->getDomainObjectReference($owner, $ownerOwner, null)
                );
            }
        }

        return $result;
    }

    /**
     * @param object $subject
     *
     * @return bool
     */
    private function hasPermissionsToManageClient($subject): bool
    {
        return
            $this->authorizationChecker->isGranted('MANAGE_API_KEY', $subject)
            && $this->authorizationChecker->isGranted('EDIT', $subject);
    }

    /**
     * @param object      $entity
     * @param object      $owner
     * @param object|null $organization
     *
     * @return DomainObjectReference
     */
    private function getDomainObjectReference($entity, $owner, $organization): DomainObjectReference
    {
        if (null === $organization) {
            return new DomainObjectReference(
                ClassUtils::getRealClass($entity),
                $this->entityIdAccessor->getIdentifier($entity),
                $this->entityIdAccessor->getIdentifier($owner)
            );
        }

        return new DomainObjectReference(
            ClassUtils::getRealClass($entity),
            $this->entityIdAccessor->getIdentifier($entity),
            $this->entityIdAccessor->getIdentifier($owner),
            $this->entityIdAccessor->getIdentifier($organization)
        );
    }

    /**
     * @return EntityManagerInterface
     */
    private function getEntityManager(): EntityManagerInterface
    {
        return $this->doctrine->getManagerForClass(Client::class);
    }
}
